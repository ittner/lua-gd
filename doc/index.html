<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
 <head>
  <title>Lua-GD Reference Manual</title>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
 </head>
  <style type="text/css">
<!--
H1 {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 18px;
    color: black;
    background-color: white;
    text-align: center;
}    

H2 {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 16px;
    color: black;
    background-color: #EAEAEA;
}    

H3 {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 14px;
    color: black;
    background-color: #EAEAEA;
}    

BODY  {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 11px;
    color: black;
    background : white;
}

A {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 11px;
    color: navy;
    text-decoration: none;
}

A:HOVER {
    text-decoration: underline;
    color: red;
    background-color: #EAEAEA;
}

HR {
    border: 1px solid #EAEAEA;
}

TABLE {
    border: 0px;
}

TR, TD {
    font-family: Verdana, Arial, helvetica, sans-serif;
    font-size: 11px;
    border: 1px solid #EAEAEA;
    background-color: white;
    padding: 0px;
    cell-spacing: 1px;
}

pre
{
    font-family: "Courier New", courier, monospace;
    color: black;
}

pre.example
{
    border: gray 1pt solid;
    padding: 2pt;
    display: block;
    font-family: "Courier New", courier, monospace;
    background-color: #eeeeee;
    color: black;
    font-size: small
}

pre.wrong
{
    border: gray 1pt solid;
    padding: 2pt;
    display: block;
    font-family: "Courier New", courier, monospace;
    background-color: #ee0000;
    color: black;
    font-size: small
}

-->
</style>
</head>

<body>

<center>
 <img src="lua-gd.png" alt="Lua-GD Logo">
 <h1>Lua-GD Reference Manual</h1>
</center>

<h2> Contents </h2>
<ul>
 <li><a href="#intro">Introduction</a>
   <ul>
     <li><a href="#intro.lua">About Lua</a></li>
     <li><a href="#intro.gd">About gd</a></li>
     <li><a href="#intro.lua-gd">About Lua-GD</a></li>
   </ul>
 </li>
 <li><a href="#license">License</a></li>
 <li><a href="#download">Download</a></li>
 <li><a href="#api">Lua-GD API</a>
   <ul>
     <li><a href="#api.load">Library loading and initialisation</a></li>
     <li><a href="#api.constants">Constants</a></li>
     <li><a href="#api.create">Image creation and destruction functions</a></li>
     <li><a href="#api.input">Image input functions</a></li>
     <li><a href="#api.output">Image output functions</a></li>
     <li><a href="#api.color">Color manipulation functions</a></li>
     <li><a href="#api.draw">Query functions</a></li>
     <li><a href="#api.draw">Drawing functions</a></li>
     <li><a href="#api.text">Text drawing functions</a></li>
     <li><a href="#api.font">Font configuration functions</a></li>
     <li><a href="#api.copy">Copying and resizing functions</a></li>
     <li><a href="#api.gifanim">GIF animation functions</a></li>
   </ul>
 </li>
 <li><a href="#examples">Examples</a>
   <ul>
     <li><a href="#examples.counter">Web Counter</a></li>
     <li><a href="#examples.clock">CGI Analog Clock</a></li>
     <li><a href="#examples.fontconfig">Freetype, Fontconfig and TrueType fonts</a></li>
     <li><a href="#examples.steg">A Steganography Application</a></li>
     <li><a href="#examples.other">Other examples</a></li>
   </ul>
 </li>
 <li><a href="#contact">Contact information</a></li>
</ul>


<a name="intro"></a>
<h2>Introduction</h2>

<a name="intro.lua"></a>
<h3>About Lua</h3>

<p> From the <a href="http://www.lua.org/refman-5.0.2.pdf"> Lua Reference
Manual</a>:

<blockquote>
  <p>Lua is an extension programming language designed to support general
  procedural programming with data description facilities. It also offers
  good support for object-oriented programming, functional programming,
  and data-driven programming. Lua is intended to be used as a powerful,
  light-weight configuration language for any program that needs one. Lua
  is implemented as a library, written in clean C (that is, in the common
  subset of ANSI C and C++).</p>

  <p>Being an extension language, Lua has no notion of a main program:
  it only works embedded in a host client, called the embedding program
  or simply the host. This host program can invoke functions to execute a
  piece of Lua code, can write and read Lua variables, and can register
  C functions to be called by Lua code. Through the use of C functions,
  Lua can be augmented to cope with a wide range of different domains,
  thus creating customized programming languages sharing a syntactical
  framework.</p>

  <p>The Lua distribution includes a stand-alone embedding program,
  <code>lua</code>, that uses the Lua library to offer a complete Lua
  interpreter. </p>

  <p> Lua means "moon" in Portuguese and is pronounced LOO-ah.</p>
</blockquote>

<p>For more information, please see the <a href="http://www.lua.org/">Lua
homepage</a>.



<a name="intro.gd"></a>
<h3>About gd</h3>

<p> From the <a href="http://www.boutell.com/gd/">gd homepage</a>: </p>

<blockquote>
  <p>gd is a graphics library. It allows your code to quickly draw images
  complete with lines, arcs, text, multiple colors, cut and paste from
  other images, and flood fills, and write out the result as a PNG or
  JPEG file. This is particularly useful in World Wide Web applications,
  where PNG and JPEG are two of the formats accepted for inline images
  by most browsers.</p>

  <p>gd is not a paint program. If you are looking for a paint program,
  you are looking in the wrong place. If you are not a programmer, you
  are looking in the wrong place, unless you are installing a required
  library in order to run an application.</p>

  <p>gd does not provide for every possible desirable graphics
  operation. It is not necessary or desirable for gd to become a
  kitchen-sink graphics package, but version 2.0 does include most
  frequently requested features, including both truecolor and palette
  images, resampling (smooth resizing of truecolor images) and so
  forth.</p>
</blockquote>

<p>For more information, please see the <a
href="http://www.boutell.com/gd/">gd homepage</a>.


<a name="intro.lua-gd"></a>
<h3>About Lua-GD</h3>


<a name="license"></a>
<h2>License</h2>

<h3>Lua-GD License</h3>

<p>Lua-GD is <em>copyrighted free software</em>, distributed under the
GNU Lesser General Public License, as follows: </p>

<pre>
This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published
by the Free Software Foundation; either version 2.1 of the License, or
(at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, write to the Free Software Foundation,
Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
</pre>

<h3>Lua-GD License</h3>


<a name="download"></a>
<h2>Download</h2>

<a name="api"></a>
<h2>Lua-GD API</h2>

<a name="api.load"></a>
<h3>Library loading and initialisation</h3>

<a name="api.constants"></a>
<h3>Constants</h3>

<h4>gd.VERSION</h4>
<p>A string with library's version information.</p>

<h4>gd.MAX_COLORS</h4>
<p>The constant 256. This is the maximum number of colors in a
palette-based PNG file according to the PNG standard, and is also the
maximum number of colors in a palette-based gd image. This of course
does not apply to truecolor images.</p>

<h4>gd.GD2_FMT_RAW</h4>
<h4>gd.GD2_FMT_COMPRESSED</h4>

<h4>gd.ARC</h4>
<h4>gd.CHORD</h4>
<h4>gd.PIE</h4>
<h4>gd.NO_FILL</h4>
<h4>gd.EDGED</h4>

<h4>gd.ANTI_ALIASED</h4>
<p>Used in place of a color when invoking a line-drawing function such
as gd.line or gd.rectangle. When <code>gd.ANTI_ALIASED</code> is used as
the color, the foreground color set with <code>gd.setAntiAliased</code>
is used, with antialiasing mechanisms to minimize any "jagged"
appearance. For more information, see <code>gd.setAntiAliased</code>.</p>

<h4>gd.BRUSHED</h4>
<p>Used in place of a color when invoking a line-drawing function
such as <code>gd.line</code> or <code>gd.rectangle</code>. When
<code>gd.BRUSHED</code> is used as the color, the brush image set with
<code>gd.setBrush</code> is drawn in place of each pixel of the line
(the brush is usually larger than one pixel, creating the effect of a
wide paintbrush). See also <code>gd.STYLED_BRUSHED</code> for a way to
draw broken lines with a series of distinct copies of an image. </p>

<h4>gd.STYLED</h4>
<h4>gd.STYLED_BRUSHED</h4>
<h4>gd.TILED</h4>
<h4>gd.TRANSPARENT</h4>

<h4>gd.FONT_TINY, gd.FONT_SMALL, gd.FONT_MEDIUM, gd.FONT_LARGE and
gd.FONT_GIANT</h4>

<p> These are standard font sizes used by <code>gd.string</code> and
<code>gd.stringUp</code>. </p>


<a name="api.create"></a>
<h3>Image creation and destruction functions</h3>


<h4>gd.create(sx, sy)</h4>
<h4>gd.createPalette(sx, sy)</h4>
<h4>gd.createTrueColor(sx, sy)</h4>
<h4>gd.createPaletteFromTrueColor(sx, sy)</h4>
<h4>gd.trueColorToPalette(sx, sy)</h4>

<p> These function will create and return a new image with the specified
X and Y size. </p>

<p>Example:</p>
<pre class="example">
-- creates a 20x20px true color image
local im = gd.createTrueColor(20, 20)
</pre>

<p>You don't need to destroy an image by yourself.  Lua has a garbage
collector that detects when an piece of information becomes useless and
"automagically" deletes it from memory. </p>

<a name="api.input"></a>
<h3>Image input functions</h3>

<h4>gd.createFromJpeg(filename)</h4>
<h4>gd.createFromGif(filename)</h4>
<h4>gd.createFromPng(filename)</h4>
<h4>gd.createFromGd(filename)</h4>
<h4>gd.createFromGd2(filename)</h4>
<h4>gd.createFromGd2Part(filename, x, y, w, h)</h4>
<h4>gd.createFromXbm(filename)</h4>
<h4>gd.createFromXpm(filename)</h4>

<p>These functions creates new images from files on disk. It will return
a new image, without modifying the files. <code>createFromGd2Part</code>
has a special feature: can copy <b>parts</b> of and GD2 image. These
functions returns <b>nil</b> on error (eg. a non-existing or corrupted
file or a file in the wrong format).</p>

<p>Example:</p>
<pre class="example">
-- copies the content of picture.png to a new image
local im = gd.createFromPng("picture.png")
</pre>

<p>Example:</p>
<pre class="example">
-- Being base.gd2 a 40x40px image, copies its upper-left part to a new image
local im = gd.createFromGd2Part("base.gd2", 0, 0, 20, 20)
</pre>


<h4>gd.createFromJpegStr(string)</h4>
<h4>gd.createFromGifStr(string)</h4>
<h4>gd.createFromPngStr(string)</h4>
<h4>gd.createFromGdStr(string)</h4>
<h4>gd.createFromGd2Str(string)</h4>
<h4>gd.createFromGd2PartStr(string, x, y, w, h)</h4>

<p>These functions creates new images from strings in memory. It will
return a new image. <code>createFromGd2PartStr</code> has a special
feature: can copy <b>parts</b> of and GD2 image. These functions returns
<b>nil</b> on error (eg. a non-string or a string with an image in the
wrong format).</p>

<p>Example:</p>
<pre class="example">
-- reads the contents of the file to a string
fp = io.open("picture.png")
str = fp:read("*a")
fp:close()

-- creates an image from the string
local im = gd.createFromPngStr(str)
</pre>


<a name="api.output"></a>
<h3>Image output functions</h3>

<h4>gdImage:jpeg(filename, quality)</h4>
<h4>gdImage:png(filename)</h4>
<h4>gdImage:pngEx(filename, compression_level)</h4>
<h4>gdImage:gif(filename)</h4>
<h4>gdImage:gd(filename)</h4>
<h4>gdImage:gd2(filename, chunkSize, format)</h4>
<h4>gdImage:wbmp(filename)</h4>

<p>These functions writes image files to the disk.  <code>jpeg</code>
allows you to specify the quality of the generated JPEG file
from 1 (worst quality, small files) to 100 (best quality, large
files). <code>pngEx</code> allows you to specify the compression
level of a PNG image, from 1 to 6 (or -1 for the default compression
level of libpng). <code>gd2</code> must receive the chunk size
(an integer, or 0 for the default) and the file format, which can be
<code>gd.GD2_FMT_RAW</code> or <code>gd.GD2_FMT_COMPRESSED</code>. These
functions returns <b>nil</b> on error (eg. permission denied to overwrite
an existing file) and <b>true</b> on success. </p>

<p>Example:</p>
<pre class="example">
-- creates a new image
local im = gd.createTrueColor(20, 20)

-- ** DO SOME ART HERE **

-- writes the image to a PNG file.
im:png("picture.png")

-- writes the image to a JPEG file.
im:jpeg("picture.jpg", 75)
</pre>


<p>To check if the writting was succeful:</p>
<pre class="example">
-- creates a new image
local im = gd.createTrueColor(20, 20)

-- ** DO SOME ART HERE **

if im:png("picture.png") then
  print("Image written to disk")
else
  print("Oops, an error...")
end
</pre>




<h4>gdImage:jpegStr(quality)</h4>
<h4>gdImage:pngStr()</h4>
<h4>gdImage:pngStrEx(compression_level)</h4>
<h4>gdImage:gifStr()</h4>
<h4>gdImage:gdStr()</h4>
<h4>gdImage:gd2Str(chunkSize, format)</h4>
<h4>gdImage:wbmpStr()</h4>

<p>These functions returns images as Lua strings.  <code>jpegStr</code>
allows you to specify the quality of the generated JPEG data
from 1 (worst quality, small string) to 100 (best quality, large
string). <code>pngStrEx</code> allows you to specify the compression
level of a PNG image, from 1 to 6 (or -1 for the default compression
level of libpng). <code>gd2Str</code> must receive the chunk size
(an integer, or 0 for the default) and the data format, which can be
<code>gd.GD2_FMT_RAW</code> or <code>gd.GD2_FMT_COMPRESSED</code>. These
functions returns <b>nil</b> on error (eg. a corrupted image). </p>

<p>Example:</p>
<pre class="example">
-- creates a new image
local im = gd.createTrueColor(20, 20)

-- ** DO SOME ART HERE **

-- writes the image to a PNG file.
im:png("picture.png")

-- writes the image to stdout in the JPEG format
io.write(im:jpegStr(75))
</pre>


<a name="api.color"></a>
<h3>Color manipulation functions</h3>


<h4>gdImage:colorAllocate(red, green, blue)</h4>

<p><code>colorAllocate()</code> finds the first available color
index in the image specified, sets its RGB values to those requested
(255 is the maximum for each), and returns the index of the new color
table entry, or an RGBA value in the case of a truecolor image; in
either case you can then use the returned value as a parameter to
drawing functions. When creating a new palette-based image, the first
time you invoke this function, you are setting the background color for
that image.</p>

<p>In the event that all <code>gd.MAX_COLORS</code> colors (256)
have already been allocated, <code>colorAllocate</code> will
return <b>nil</b> to indicate failure. (This is not uncommon when working
with existing PNG files that already use 256 colors.) Note that
<code>colorAllocate</code> does not check for existing colors that match
your request; see <code>colorExact</code>, <code>colorClosest</code>
and <code>colorClosestHWB</code> for ways to locate existing colors
that approximate the color desired in situations where a new color is
not available.</p>


<h4>gdImage:colorAllocateAlpha(red, green, blue, alpha)</h4>

<p><code>colorAllocateAlpha</code> finds the first available color index
in the image specified, sets its RGBA values to those requested (255 is
the maximum for red, green and blue, and 127 represents full transparency
for alpha), and returns the index of the new color table entry, or an RGBA
value in the case of a truecolor image; in either case you can then use
the returned value as a parameter to drawing functions. When creating
a new palette-based image, the first time you invoke this function,
you are setting the background color for that image.</p>

<p>In the event that all <code>gd.MAX_COLORS</code> colors (256) have
already been allocated, <code>colorAllocateAlpha</code> will return
<b>nil</b> to indicate failure. (This is not uncommon when working with
existing palette-based PNG files that already use 256 colors.) Note
that <code>colorAllocateAlpha</code> does not check for existing
colors that match your request; see <code>colorExactAlpha</code> and
<code>colorClosestAlpha</code> for ways to locate existing colors that
approximate the color desired in situations where a new color is not
available. Also see <code>colorResolveAlpha</code>.</p>



<h4>gdImage:colorClosest(red, green, blue)</h4>

<p><code>colorClosest</code> searches the colors which have been defined
thus far in the image specified and returns the index of the color with
RGB values closest to those of the request. (Closeness is determined
by Euclidian distance, which is used to determine the distance in
three-dimensional color space between colors.) </p>

<p>If no colors have yet been allocated in the image,
<code>colorClosest</code> returns <b>nil</b>.</p>

<p>When applied to a truecolor image, this function always succeeds in
returning the desired color.</p>

<p>This function is most useful as a backup method for choosing a
drawing color when an image already contains <code>gd.MAX_COLORS</code>
(256) colors and no more can be allocated. (This is not uncommon when
working with existing PNG files that already use many colors.) See
<code>colorExact</code> for a method of locating exact matches only.</p>


<h4>gdImage:colorClosestAlpha(red, green, blue, alpha)</h4>

<p> <code>colorClosestAlpha</code> searches the colors which have been
defined thus far in the image specified and returns the index of the
color with RGBA values closest to those of the request. (Closeness is
determined by Euclidian distance, which is used to determine the distance
in four-dimensional color/alpha space between colors.) </p>

<p> If no colors have yet been allocated in the image,
<code>colorClosestAlpha</code> returns <b>nil</b>. </p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>

<p> This function is most useful as a backup method for
choosing a drawing color when a palette-based image already
contains <code>gd.MAX_COLORS</code> (256) colors and no more can be
allocated. (This is not uncommon when working with existing palette-based
PNG files that already use many colors.) See <code>colorExactAlpha</code>
for a method of locating exact matches only.</p>


<h4>gdImage:colorClosestHWB(red, green, blue)</h4>

<p> <code>colorClosestHWB</code> searches the colors which have been
defined thus far in the image specified and returns the index of the color
with hue, whiteness and blackness closest to the requested color. This
scheme is typically superior to the Euclidian distance scheme used by
<code>colorClosest</code>. </p>

<p> If no colors have yet been allocated in the image,
<code>colorClosestHWB</code> returns <b>nil</b>. </p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>

<p> This function is most useful as a backup method for choosing a
drawing color when an image already contains <code>gd.MAX_COLORS</code>
(256) colors and no more can be allocated. (This is not uncommon when
working with existing PNG files that already use many colors.) See
<code>colorExact</code> for a method of locating exact matches only. </p>


<h4>gdImage:colorExact(red, green, blue)</h4>

<p> <code>colorExact</code> searches the colors which have been defined
thus far in the image specified and returns the index of the first
color with RGB values which exactly match those of the request. If no
allocated color matches the request precisely, <code>colorExact</code>
returns <b>nil</b>. See <code>colorClosest</code> for a way to find the
color closest to the color requested.</p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>


<h4>gdImage:colorExactAlpha(red, green, blue, alpha)</h4>

<p> <code>colorExactAlpha</code> searches the colors which have
been defined thus far in the image specified and returns the
index of the first color with RGBA values which exactly match
those of the request. If no allocated color matches the request
precisely, <code>colorExactAlpha</code> returns <b>nil</b>. See
<code>colorClosestAlpha</code> for a way to find the color closest to
the color requested.</p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>

<h4>gdImage:colorResolve(red, green, blue)</h4>

<p> <code>colorResolve</code> searches the colors which have been defined
thus far in the image specified and returns the index of the first color
with RGB values which exactly match those of the request. If no allocated
color matches the request precisely, then <code>colorResolve</code>
tries to allocate the exact color. If there is no space left in
the color table then ColorResolve returns the closest color (as in
<code>colorClosest</code>). This function always returns an index of a
color. </p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>


<h4>gdImage:colorResolveAlpha(red, green, blue, alpha)</h4>

<p> <code>colorResolveAlpha</code> searches the colors which have
been defined thus far in the image specified and returns the index
of the first color with RGBA values which exactly match those of the
request. If no allocated color matches the request precisely, then
<code>colorResolveAlpha</code> tries to allocate the exact color. If there
is no space left in the color table then <code>colorResolveAlpha</code>
returns the closest color (as in <code>colorClosestAlpha</code>). This
function always returns an index of a color. </p>

<p> When applied to a truecolor image, this function always succeeds in
returning the desired color. </p>


<h4>gdImage:colorsTotal()</h4>
<p> This function returns the number of colors currently allocated in a
palette image. For truecolor images, the result of this call is undefined
and should not be used. </p>


<h4>gdImage:red(color)</h4>
<p> This function returns the red portion of the specified color in the
image. This function works for both palette and truecolor images. </p>


<h4>gdImage:blue(color)</h4>
<p> This function returns the blue portion of the specified color in the
image. This function works for both palette and truecolor images. </p>


<h4>gdImage:green(color)</h4>
<p> This function returns the green portion of the specified color in the
image. This function works for both palette and truecolor images. </p>


<h4>gdImage:alpha(color)</h4>

<p> This function returns the alpha portion of the specified color in the
image. This function works for both palette and truecolor images. </p>


<h4>gdImage:getTransparent()</h4>
<p> This function returns the current transparent color index in
the image. If there is no transparent color, <code>getTransparent</code>
returns <b>nil</b>. </p>


<h4>gdImage:colorTransparent(color)</h4>

<p><code>colorTransparent</code> sets the transparent color index for
the specified image to the specified index. To indicate that there
should be no transparent color, invoke <code>colorTransparent</code>
with a color index of <b>nil</b> (or passing no color index). Note that
JPEG images do not support transparency, so this setting has no effect
when writing JPEG images.</p>

<p>The color index used should be an index allocated by
<code>colorAllocate</code>, whether explicitly invoked by your code or
implicitly invoked by loading an image. In order to ensure that your
image has a reasonable appearance when viewed by users who do not
have transparent background capabilities (or when you are writing a
JPEG-format file, which does not support transparency), be sure to give
reasonable RGB values to the color you allocate for use as a transparent
color, even though it will be transparent on systems that support PNG
transparency.</p>


<h4>gdImage:colorDeallocate(color)</h4>

<p> <code>colorDeallocate</code> marks the specified color as being
available for reuse. It does not attempt to determine whether the
color index is still in use in the image. After a call to this
function, the next call to <code>colorAllocate</code> for the same
image will set new RGB values for that color index, changing the color
of any pixels which have that index as a result. If multiple calls to
<code>colorDeallocate</code> are made consecutively, the lowest-numbered
index among them will be reused by the next <code>colorAllocate</code>
call.<p>


<a name="api.query"></a>
<h3>Query functions</h3>

<h4>gdImage:boundsSafe(x, y)</h4>

<p> <code>boundsSafe</code> returns <b>true</b> if the specified point
is within the current clipping rectangle, <b>false</b> if not. The
clipping rectangle is set by <code>setClip</code> and defaults to the
entire image. This function is intended primarily for use by those who
wish to add functions to Lua-GD. All of the drawing functions already
clip safely. </p>


<h4>gdImage:getPixel(x, y)</h4>
<p><code>getPixel</code> returns the color index of a particular pixel.</p>

<h4>gdImage:sizeX()</h4>
<p><code>sizeX</code> returns the width of the image in pixels.</p>


<h4>gdImage:sizeY()</h4>
<p><code>sizeY</code> returns the height of the image in pixels.</p>


<h4>gdImage:sizeXY()</h4>
<p><code>sizeXY</code> returns the width and the height of the image
in pixels. This function has no C equivalent because, unlike Lua,
C functions cannot return multiple values.</p>

<p>Example: 
<pre class="example">
local x, y = im:sizeXY()
</pre>
</p>


<h4>gdImage:getClip()</h4>
<p>Fetches the boundaries of the current clipping rectangle. This function
returns four numbers.</p>

<p>Example: 
<pre class="example">
local x1, y1, x2, y2 = im:getClip()
</pre>
</p>


<h4>gdImage:setClip(x1, y1, x2, y2)</h4>

<p> Establishes a clipping rectangle. Once <code>setClip</code> has been
called, all future drawing operations will remain within the specified
clipping area, until a new <code>setClip</code> call takes place. For
instance, if a clipping rectangle of 25, 25, 75, 75 has been set within
a 100x100 image, a diagonal line from 0,0 to 99,99 will appear only
between 25,25 and 75,75. </p>


<a name="api.draw"></a>
<h3>Drawing functions</h3>

<h4>gdImage:setPixel(x, y, color)</h4>
<p> <code>setPixel</code> sets a pixel to a particular color index. </p>

<h4>gdImage:line(x1, y1, x2, y2, color)</h4>

<p> <code>line</code> is used to draw a line between two endpoints
(x1,y1 and x2, y2). The line is drawn using the color index
specified. Note that the color index can be an actual color returned
by <code>colorAllocate</code> or one of <code>gd.STYLED</code>,
<code>gd.BRUSHED</code> or <code>gd.STYLED_BRUSHED</code>. </p>


<h4>gdImage:rectangle(x1, y1, x2, y2, color)</h4>

<p> <code>rectangle</code> is used to draw a rectangle with the two
corners (upper left first, then lower right) specified, using the color
index specified. </p>


<h4>gdImage:filledRectangle(x1, y1, x2, y2, color)</h4>

<p> <code>filledRectangle</code> is used to draw a rectangle with the
two corners (upper left first, then lower right) specified, filled using
the color index specified. </p>


<h4>gdImage:polygon({ { x1, y1 }, { x2, y2 } ... }, color)</h4>

<p> <code>polygon</code> is used to draw a polygon with the verticies
(at least 3) specified in the table, using the color index specified </p>

<p>Example: 
<pre class="example">
im = assert(gd.createTrueColor(80, 80))
black = im:colorAllocate(0, 0, 0)
white = im:colorAllocate(255, 255, 255)
im:polygon( { { 10, 10 }, { 10, 20 }, { 20, 20 }, { 20, 10 } }, white)
im:png("out.png")
</pre>
</p>



<h4>gdImage:filledPolygon({ { x1, y1 }, { x2, y2 } ... }, color)</h4>

<p> <code>polygon</code> is used to fill a polygon with the verticies
(at least 3) specified in the table, using the color index specified </p>

<p>Example: 
<pre class="example">
im = assert(gd.createTrueColor(80, 80))
black = im:colorAllocate(0, 0, 0)
white = im:colorAllocate(255, 255, 255)
im:filledPolygon( { { 30, 30 }, { 30, 40 }, { 40, 40 }, { 40, 30 } }, white)
im:png("out.png")
</pre>
</p>




<h4>gdImage:openPolygon({ { x1, y1 }, { x2, y2 } ... }, color)</h4>

<p> <code>openPolygon</code> is used to draw a sequence of lines with the
verticies (at least 3) specified, using the color index specified. Unlike
<code>polygon</code>, the enpoints of the line sequence are not connected to
a closed polygon. </p>

<p>Example: 
<pre class="example">
im = assert(gd.createTrueColor(80, 80))
black = im:colorAllocate(0, 0, 0)
white = im:colorAllocate(255, 255, 255)
im:openPolygon( { { 50, 50 }, { 50, 60 }, { 60, 60 }, { 60, 50 } }, white)
im:png("out.png")
</pre>
</p>



<h4>gdImage:arc(cx,  cy,  w,  h,  s,  e, color)</h4>

<p> <code>arc</code> is used to draw a partial ellipse centered at the
given point, with the specified width and height in pixels. The arc
begins at the position in degrees specified by <b>s</b> and ends at the
position specified by <b>e</b>. The arc is drawn in the color specified
by the last argument. A circle can be drawn by beginning from 0 degrees
and ending at 360 degrees, with width and height being equal. <b>e</b>
must be greater than <b>s</b>. Values greater than 360 are interpreted
modulo 360. </p>


<h4>gdImage:filledArc(cx,  cy,  w,  h,  s,  e, color, style)</h4>

<p> <code>arc</code> is used to draw a partial ellipse centered at the
given point, with the specified width and height in pixels. The arc
begins at the position in degrees specified by <b>s</b> and ends at the
position specified by <b>e</b>. The arc is filled in the color specified
by <b>color</b>. A circle can be drawn by beginning from 0 degrees
and ending at 360 degrees, with width and height being equal. <b>e</b>
must be greater than <b>s</b>. Values greater than 360 are interpreted
modulo 360. The last argument is a sum of the following possibilities:
<code>gd.ARC</code>, <code>gd.CHORD</code>, <code>gd.PIE</code>
(synonym for <code>gd.CHORD</code>), <code>gd.NO_FILL</code> and
<code>gd.EDGED</code>. <code>gd.ARC</code> and <code>gd.CHORD</code> are
mutually exclusive; <code>gd.CHORD</code> just connects the starting
and ending angles with a straight line, while <code>gd.ARC</code>
produces a rounded edge. <code>gd.PIE</code> is a synonym for
<code>gd.ARC</code>. <code>gd.NO_FILL</code> indicates that the arc
or chord should be outlined, not filled. <code>gd.EDGED</code>, used
together with <code>gd.NO_FILL</code>, indicates that the beginning and
ending angles should be connected to the center; this is a good way to
outline (rather than fill) a 'pie slice'.
</p>


<h4>gdImage:filledEllipse(cx, cy, w, h, color)</h4>

<p> <code>filledEllipse</code> is used to draw an ellipse centered at the
given point, with the specified width and height in pixels. The ellipse
is filled in the color specified by the last argument.</p>


<h4>gdImage:fill(x, y, c)</h4>

<p> <code>fill</code> floods a portion of the image with the specified
color, beginning at the specified point and flooding the surrounding
region of the same color as the starting point. For a way of flooding
a region defined by a specific border color rather than by its interior
color, see <code>fillToBorder</code>. </p>

<p>The fill color can be <code>gd.TILED</code>, resulting in a tile
fill using another image as the tile. However, the tile image cannot be
transparent. If the image you wish to fill with has a transparent color
index, call <code>setTransparent</code> on the tile image and set the
transparent color index to <b>nil</b> to turn off its transparency. </p>

<p> Note that <code>fill</code> is recursive. It is not the most
naive implementation possible, and the implementation is expected to
improve, but there will always be degenerate cases in which the stack
can become very deep. This can be a problem in MSDOS and MS Windows 3.1
environments. (Of course, in a Unix or Windows 95/98/NT environment with
a proper stack, this is not a problem at all.) </p>


<h4>gdImage:fillToBorder( x, y, border_color, color)</h4>

<p> <code>fillToBorder</code> floods a portion of the image with the
specified color, beginning at the specified point and stopping at the
specified border color. For a way of flooding an area defined by the
color of the starting point, see <code>fill</code>. </p>

<p> The border color cannot be a special color such as
<code>gd.TILED</code>; it must be a proper solid color. The fill color
can be, however. </p>

<p> Note that <code>fillToBorder</code> is recursive. It is not the most
naive implementation possible, and the implementation is expected to
improve, but there will always be degenerate cases in which the stack
can become very deep. This can be a problem in MSDOS and MS Windows 3.1
environments. (Of course, in a Unix or Windows 95/98/NT environment with
a proper stack, this is not a problem at all.) </p>


<a name="api.text"></a>
<h3>Text drawing functions</h3>

<h4>gdImage:string(font, x, y, string, color);</h4>
<h4>gdImage:stringUp(font, x, y, string, color);</h4>
<h4>gdImage:char(font, x, y, char, color);</h4>
<h4>gdImage:charUp(font, x, y, char, color);</h4>
<h4>gdImage:stringFT(color, fontname, size, angle, x, y, string)</h4>
<h4>gdImage:stringFTCircle(cx, cy, radius, textRadius, fillPortion, fontname, points, top, bottom, color)</h4>


<a name="api.font"></a>
<h3>Font configuration functions</h3>

<h4>gd.fontCacheSetup()</h4>
<h4>gd.fontCacheShutdown()</h4>
<h4>gd.useFontConfig(bool)</h4>


<a name="api.copy"></a>
<h3>Image copying, resizing and transformation functions</h3>

<h4>gd.copy(dstImage, srcImage, dstX, dstY, srcX, srcY, w, h)</h4>
<h4>dstImage:copy(srcImage, dstX, dstY, srcX, srcY, w, h)</h4>

<h4>gd.copyResized(dstImage, srcImage, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH)</h4>
<h4>dstImage:copyResized(srcImage, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH)</h4>

<h4>gd.copyResampled(dstImage, srcImage, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH)</h4>
<h4>dstImage:copyResampled(srcImage, dstX, dstY, srcX, srcY, dstW, dstH, srcW, srcH)</h4>

<h4>gd.copyRotated(dstImage, srcImage, dstX, dstY, srcX, srcY, srcW, srcH, ang)</h4>
<h4>dstImage:copyRotated(srcImage, dstX, dstY, srcX, srcY, srcW, srcH, ang)</h4>

<h4>gd.copyMerge(dstImage, srcImage, dstX, dstY, srcX, srcY, w, h, pct)</h4>
<h4>dstImage:copyMerge(srcImage, dstX, dstY, srcX, srcY, w, h, pct)</h4>

<h4>gd.copyMergeGray(dstImage, srcImage, dstX, dstY, srcX, srcY, w, h, pct)</h4>
<h4>dstImage:copyMergeGray(srcImage, dstX, dstY, srcX, srcY, w, h, pct)</h4>

<h4>gd.paletteCopy(dstImage, srcImage)</h4>
<h4>dstImage:paletteCopy(srcImage)</h4>


<h4>gdImage:squareToCircle(radius)</h4>
<h4>gdImage:sharpen(pct)</h4>




<a name="api.gifanim"></a>
<h3>GIF animation functions</h3>

<h4>gdImage:gifAnimBegin(filename, globalCM, loops)</h4>
<h4>gdImage:gifAnimAdd(filename, localCM, leftOfs, topOfs, delay, disposal [, previm])</h4>
<h4>gdImage:gifAnimEnd(filename)</h4>
<h4>gdImage:gifAnimBeginStr(globalCM, loops)</h4>
<h4>gdImage:gifAnimAddStr(localCM, leftOfs, topOfs, delay, disposal [, previm])</h4>
<h4>gdImage:gifAnimEndStr()</h4>





<a name="examples"></a>
<h2>Examples</h2>

<a name="examples.counter"></a>
<h3>Web Counter</h3>
<pre class="example">
#!/usr/bin/env lua

-- counter.lua -- a web counter in Lua!
-- (c) 2004 Alexandre Erwin Ittner

datafile="counter.txt"

load_gd = assert(loadlib("libluagd.so", "luaopen_gd"))
load_gd()

fp = io.open(datafile, "r")
if fp then
  cnt = fp:read("*a")
  fp:close()
else
  cnt = 0
end
cnt = cnt + 1
fp = io.open(datafile, "w")
if fp then
  fp:write(cnt)
  fp:close()
end
cnt = cnt + 1

sx = string.len(cnt) * 8
if sx == 0 then
 sx = 10
end

im = gd.create(sx, 15)
-- first allocated color defines the background.
white = im:colorAllocate(255, 255, 255)
im:colorTransparent(white)
black = im:colorAllocate(0, 0, 0)
im:string(gd.FONT_MEDIUM, 1, 1, cnt, black)

print("Content-type: image/png\n")
io.write(im:pngStr())
</pre>


<a name="examples.clock"></a>
<h3>CGI Analog clock</h3>

<img src="clock-example.png" alt="Clock Example output">
<pre class="example">
#!/usr/bin/env lua

-- a cgi script that draws an analog clock with lua and lua-gd
-- (c) 2004 Alexandre Erwin Ittner

load_gd = assert(loadlib("libluagd.so", "luaopen_gd"))
load_gd()

function createClock(size, hours, minutes)
  local im = gd.createTrueColor(size, size)
  local white = im:colorAllocate(255, 255, 255)
  local gray = im:colorAllocate(128, 128, 128)
  local black = im:colorAllocate(0, 0, 0)
  local blue = im:colorAllocate(0, 0, 128)
  local cxy = size/2

  im:filledRectangle(0, 0, size, size, white)
  im:setThickness(math.max(1, size/100))
  im:arc(cxy, cxy, size, size, 0, 360, black)

  local ang = 0
  local rang, gsize
  while ang &lt; 360 do
    rang = math.rad(ang)
    if math.mod(ang, 90) == 0 then
      gsize = 0.75
    else
      gsize = 0.85
    end
    im:line(
      cxy + gsize * cxy * math.sin(rang),
      size - (cxy + gsize * cxy * math.cos(rang)),
      cxy + cxy * 0.9 * math.sin(rang),
      size - (cxy + cxy * 0.9 * math.cos(rang)),
      gray)
    ang = ang + 30
  end

  im:setThickness(math.max(1, size/50))
  im:line(cxy, cxy,
    cxy + 0.45 * size * math.sin(math.rad(6*minutes)),
    size - (cxy + 0.45 * size * math.cos(math.rad(6*minutes))),
    blue)

  im:setThickness(math.max(1, size/25))
  rang = math.rad(30*hours + minutes/2)
  im:line(cxy, cxy, 
    cxy + 0.25 * size * math.sin(rang),
    size - (cxy + 0.25 * size * math.cos(rang)),
    blue)

  im:setThickness(1)
  local sp = math.max(1, size/20)
  im:filledArc(cxy, cxy, sp, sp, 0, 360, black, gd.ARC)

  return im
end

dh = os.date("*t")
im = createClock(100, dh.hour, dh.min)

print("Content-type: image/png")
print("Refresh: 60")            -- Ask browser to reload the image after 60s
print("Pragma: no-cache")       -- Can mozilla understand this?
print("Expires: Thu Jan 01 00:00:00 UTC 1970")  -- Marks as expired
print("")

io.write(im:pngStr())
</pre>


<a name="examples.fontconfig"></a>
<h3>Freetype, Fontconfig and TrueType fonts</h3>

<img src="fontconfig-example.png" alt="Fontconfig Example output">
<pre class="example">
-- The fonts used in this example comes with Microsoft operating systems 
-- and can be downloaded from http://corefonts.sourceforge.net

load_gd = assert(loadlib("libluagd.so", "luaopen_gd"))
load_gd()

im = gd.createTrueColor(220, 190)
white = im:colorAllocate(255, 255, 255)
black = im:colorAllocate(0, 0, 0)
x, y = im:sizeXY()
im:filledRectangle(0, 0, x, y, white)

gd.useFontConfig(true)
im:stringFT(black, "Arial", 20, 0, 10, 30, "Standard Arial")
im:stringFT(black, "Arial:bold", 20, 0, 10, 60, "Bold Arial")
im:stringFT(black, "Arial:italic", 20, 0, 10, 90, "Italic Arial")
im:stringFT(black, "Arial:bold:italic", 20, 0, 10, 120, "Italic Bold Arial")
im:stringFT(black, "Times New Roman", 20, 0, 10, 150, "Times New Roman")
im:stringFT(black, "Comic Sans MS", 20, 0, 10, 180, "Comic Sans MS")

im:png("./out.png")
os.execute("display out.png")
</pre>


<a name="examples.steg"></a>
<h3>A Steganography Application</h3>

<table border="0">
 <tr>
  <td width="256"><img src="lena.png" width="256" height="256"> </td>
  <td width="256"><img src="lena_msg.png" width="256" height="256"> </td>
  <td width="256"><img src="lena_diff.png" width="256" height="256"> </td>
 </tr>
 <tr>
  <td width="256"> The standard "Lena" test image. </td>
  <td width="256"> Image with a staganographic message (no visible changes).</td>
  <td width="256"> Resulting image from <code>steg.lua diff</code> showing
    the pixels changed to store the message. </td>
 </tr>
</table>

<pre class="example">
#/usr/bin/env lua
--[[

Using Lua-GD to write steganographic messages in PNG images.
(c) 2005 Alexandre Erwin Ittner &lt;aittner@netuno.com.br&gt;

This program is free software; you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
for more details.


                      Steganography with Lua-GD

Steganography is the technique of writing hidden messages in such a way
that no one apart from the intended recipient knows of the existence of
the message; this is in contrast to cryptography, where the existence
of the message is clear, but the meaning is obscured. Generally a
steganographic message will appear to be something else, like a shopping
list, an article, a picture, or some other "cover" message. In the
digital age, steganography works by replacing bits of useless or unused
data in regular computer files (such as graphics, sound, text, HTML, or
even floppy disks) with bits of different, invisible information. This
hidden information can be plain text, cipher text or even images.


                           A Simple Example

If Alice wants to send a secret message to Bob through an insecure
channel, she can use some encryption software (like GnuPG) to encrypt
the message with Bob's public key. It's a good solution because no
one unless Bob will be able to read the message. She can also sign the
message so Bob will know that the message really comes from her. BUT,
a potential attacker will know that a ciphered message was sent. If the
attacker has control over the communication channel, he can block the
message in some way that Bob will never receive it. If Alice also HIDES
the ciphertext in a unsuspected piece of information (like a photo of her
cat) the attacker will not detect it and the message will arrive to Bob.

This program will help Alice to hide some arbitrary text in a PNG image by
replacing the least significant bits of each color channel of some pixels
with bits from the encrypted message. PNG or other loseless compression
algorithm are mandatory here: if the image will be compressed by a
lossy algorithm, the hidden data can be destroyed. The maximum length
of the message are limited by the image's size (each byte needs 8 color
channels or 2 pixels and 2 channels from the next pixel). So, image must
heave at least "ceil((length+1)*8/3)" pixels (the extra byte is the NUL
marker for the end of the string). So, if Alice's message is "Meet me
in the secret place at nine o'clock.", she will encrypt and sign it to
something like "PyJYDpz5LCOSHPiXDvLHmVzxLV8qS7EFvZnoo1Mxk+BlT+7lMjpQKs"
(imagine Alice's cat walking in you keyboard :). This is the ciphertext
that will be sent to Bob through the image.

The following table shows what happens to the first eight pixels from
the image when mixed to the first three bytes from the encrypted massage:


         +-----+---+----------+-----------------+----------+
         | Pix | C | Orig img |     Message     | New img  |
         |  #  |   |   bits   | Chr | Dec | Bin |   bits   |
         +-----+---+----------+-----+-----+-----+----------+
         |     | R | 01010010 |     |     |  0  | 01010010 |
         |  1  | G | 00101010 |     |     |  1  | 00101011 |
         |_____| B | 00010101 |     |     |  0  | 00010100 |
         |     | R | 11100100 |  P  | 080 |  1  | 11100101 |
         |  2  | G | 00100100 |     |     |  0  | 00100100 |
         |_____| B | 01001111 |     |     |  0  | 01001110 |
         |     | R | 01010010 |     |     |  0  | 01010010 |
         |  3  | G | 00101110 |_____|_____|__0__| 00101110 |
         |_____| B | 00111001 |     |     |  0  | 00111000 |
         |     | R | 10010110 |     |     |  1  | 10010111 |
         |  4  | G | 01011101 |     |     |  1  | 01011101 |
         |_____| B | 00100101 |  y  | 121 |  1  | 00100101 |
         |     | R | 01001001 |     |     |  1  | 01001001 |
         |  5  | G | 10110110 |     |     |  0  | 10110110 |
         |_____| B | 00010101 |     |     |  0  | 00010100 |
         |     | R | 00110100 |_____|_____|__1__| 00110101 |
         |  6  | G | 01000111 |     |     |  0  | 01000110 |
         |_____| B | 01001000 |     |     |  1  | 01001001 |
         |     | R | 01010110 |     |     |  0  | 01010110 |
         |  7  | G | 00011001 |     |     |  0  | 00011000 |
         |_____| B | 10010100 |  J  | 074 |  1  | 10010101 |
         |     | R | 00010101 |     |     |  0  | 00010100 |
         |  8  | G | 01011010 |     |     |  1  | 01011011 |
         |     | B | 01010001 |     |     |  0  | 01010000 |
         +-----+---+----------+-----+-----+-----+----------+


When Bob wants to read the message he will extract the least significant
bit (LSB) from each color channel from some pixels of the image and
join them to get the original ciphertext. A NULL character (ASCII #0)
will mark the end of the message within the image, so will know when
stop. Of course, this program will also do this boring job for Bob.

--]]


require "gd"


function getLSB(n)
  return math.mod(n, 2) ~= 0
end


-- Bizarre way to do some bit-level operations without bitlib.
function setLSB(n, b)
  if type(b) == "number" then
    if b == 0 then
      b = false
    else
      b = true
    end
  end
  if getLSB(n) then
    if b then
      return n
    elseif n &gt; 0 then
      return n - 1
    else
      return n + 1
    end
  else
    if not b then
      return n
    elseif n &gt; 0 then
      return n - 1
    else
      return n + 1
    end
  end
end


function intToBitArray(n)
  local ret = {}
  local i = 0
  while n ~= 0 do
    ret[i] = getLSB(n)
    n = math.floor(n/2)
    ret.size = i
    i = i + 1
  end 
  return ret
end


function printBitArray(a)
  local i
  for i = a.size,0,-1 do
    if a[i] then
      io.write("1")
    else    
      io.write("0")
    end
  end
end


function mergeMessage(im, msg)
  local w, h = im:sizeXY()
  msg = msg .. string.char(0)
  local len = string.len(msg)
  if h * w &lt; len * 8 then
    return nil
  end
  local x, y = 0, 0
  local oim = gd.createTrueColor(w, h)
  local i = 1
  local a2, c, nc, chr
  local a = {}
  local s, e = 1, 1
  local rgb = {}

  while y &lt; h do
    c = im:getPixel(x, y)
    rgb.r = im:red(c)
    rgb.g = im:green(c)
    rgb.b = im:blue(c)
    if i &lt;= len and  e - s &lt; 3 then
      a2 = intToBitArray(string.byte(string.sub(msg, i, i)))
      for cnt = 7,0,-1 do
        a[e+7-cnt] = a2[cnt]
      end
      i = i + 1
      e = e + 8
    end
    if e - s &gt; 0 then
      rgb.r = setLSB(rgb.r, a[s])
      a[s] = nil
      s = s + 1
    end
    if e - s &gt; 0 then
      rgb.g = setLSB(rgb.g, a[s])
      a[s] = nil
      s = s + 1
    end
    if e - s &gt; 0 then
      rgb.b = setLSB(rgb.b, a[s])
      a[s] = nil
      s = s + 1
    end
    nc = oim:colorResolve(rgb.r, rgb.g, rgb.b)
    oim:setPixel(x, y, nc)
    x = x + 1
    if x == w then
      x = 0
      y = y + 1
    end
  end

  return oim, (i-1)*8, w*h
end


function getMessage(im)
  local msg = ""
  local w, h = im:sizeXY()
  local x, y = 0, 0
  local a = {}
  local s, e = 1, 1
  local b = 0
  local c

  while y &lt;= h do
    c = im:getPixel(x, y)
    a[e] = getLSB(im:red(c))
    a[e+1] = getLSB(im:green(c))
    a[e+2] = getLSB(im:blue(c))
    e = e + 2
    if e - s &gt;= 7 then
      b = 0
      for p = s, s+7 do
        b = b * 2
        if a[p] then
          b = b + 1
        end
        a[p] = nil
      end
      s = s + 8
      if b == 0 then
        return msg
      else
        msg = msg .. string.char(b)
      end
    end
    e = e + 1
    x = x + 1
    if x == w then
      x = 0
      y = y + 1
    end
  end

  return msg
end


function compare(fimg1, fimg2)
  local im1 = gd.createFromPng(fimg1)
  if not im1 then
    print("ERROR: " .. fimg1 .. " bad PNG data.")
    os.exit(1)
  end
  local im2 = gd.createFromPng(fimg2)
  if not im2 then
    print("ERROR: " .. fimg2 .. " bad PNG data.")
    os.exit(1)
  end
  local w1, h1 = im1:sizeXY()
  local w2, h2 = im2:sizeXY()
  if w1 ~= w2 or h1 ~= h2 then
    print("ERROR: Images with different sizes.")
    os.exit(1)
  end
  local oim = gd.createTrueColor(w1, h1)
  local x, y = 0, 0
  local c1, c2, oc, f, fc
  while y &lt; h1 do
    c1 = im1:getPixel(x, y)
    c2 = im2:getPixel(x, y)
    if im1:red(c1) ~= im2:red(c2)
    or im1:green(c1) ~= im2:green(c2)
    or im1:blue(c1) ~= im2:blue(c2) then
      oc = oim:colorResolve(im2:red(c2), im2:green(c2), im2:blue(c2))
      oim:setPixel(x, y, oc)
    else
      f = math.floor((im1:red(c1) + im1:green(c1) + im1:blue(c1))/6.0)
      fc = oim:colorResolve(f,f,f)
      oim:setPixel(x, y, fc)
    end
    x = x + 1
    if x == w1 then
      x = 0
      y = y + 1
    end
  end
  return oim
end
    

function usage()
  print("Usage:")
  print(" lua steg.lua hide &lt;input file&gt; &lt;output file&gt;")
  print(" lua steg.lua show &lt;input file&gt;")
  print(" lua steg.lua diff &lt;input file 1&gt; &lt;input file 2&gt; &lt;output file&gt;")
  print("")
  print(" hide - Reads a message from stdin and saves into &lt;output file&gt;.")
  print(" show - Reads a message from &lt;input file&gt; and prints it to stdout.")
  print(" diff - Compares two images and writes the diff to &lt;output file&gt;.")
  print("")
  print(" WARNING: All files used here must be in the PNG format!")
end


if not arg[1] or not arg[2] then
  usage()
  os.exit(1)
end

if arg[1] == "show" then
  im = gd.createFromPng(arg[2])
  if not im then    
    print("ERROR: Bad image data.")
    os.exit(1)
  end
  io.write(getMessage(im))
  os.exit(0)
end

if arg[1] == "hide" then
  if not arg[3] then
    usage()
    os.exit(1)
  end
  im = gd.createFromPng(arg[2])
  if not im then
    print("ERROR: Bad image data.")
    os.exit(1)
  end
  print("Type your message and press CTRL+D to finish.")
  msg = io.read("*a")
  oim, l, t = mergeMessage(im, msg)
  if not oim then
    print("ERROR: Image is too small for the message.")
    os.exit(1)
  end
  if not oim:png(arg[3]) then
    print("ERROR: Failed to write output file.")
    os.exit(1)
  end
  print(string.format("DONE: %2.2f%% of the image used to store the message.",
    l/t*100.0))
  os.exit(0)
end

if arg[1] == "diff" then
  if not arg[3] and arg[4] then
    usage()
    os.exit(1)
  end
  oim = compare(arg[2], arg[3])
  if not oim:png(arg[4]) then
    print("ERROR: Failed to write output file.")
    os.exit(1)
  end
  os.exit(0)
end

usage()
os.exit(1)
</pre>



<a name="examples.other"></a>
<h3>Other examples</h3>
<p> There are some useful examples in the <code>demos</code> directory
within the distribution package. </p>


<a name="contact"></a>

<h2>Contact information</h2>

<p>Author: <b>Alexandre Erwin Ittner</b> </p>

<p>E-mail: <a href="mailto:aittner AT netuno DOT com DOT br">aittner
<em>AT</em> netuno <em>DOT</em> com <em>DOT</em> br</a> (e-mail obfuscated
to avoid spam-bots. Please replace <em>AT</em> with "@" and <em>DOT</em>
with ".").</p>

<p>GnuPG/PGP Key: <a href="http://users.netuno.com.br/aittner/AlexandreErwinIttner.pub.asc">0x0041A1FB</a> (key fingerprint: <code>9B49 FCE2 E6B9 D1AD 6101  29AD 4F6D F114 0041 A1FB</code>).</p>

<p>Homepage: <a href="http://users.netuno.com.br/aittner/">http://users.netuno.com.br/aittner/</a>.</p>

<p>Real-world location: Jaragu do Sul, Santa Catarina, Brazil.</p>


<hr>
$Id$
</body>
</html>


  
